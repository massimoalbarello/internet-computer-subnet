syntax = "proto3";
package state.metadata.v1;
import "bitcoin/v1/bitcoin.proto";
import "types/v1/types.proto";
import "state/ingress/v1/ingress.proto";
import "state/queues/v1/queues.proto";
import "registry/routing_table/v1/routing_table.proto";
import "registry/subnet/v1/subnet.proto";
import "registry/crypto/v1/crypto.proto";
import "google/protobuf/wrappers.proto";

message NodeTopology {
    string ip_address = 1;
    uint32 http_port = 2;
}

message SubnetTopologyEntry {
    types.v1.NodeId node_id = 1;
    NodeTopology node_topology = 2;
}

message SubnetTopology {
    repeated SubnetTopologyEntry nodes = 1;
    // The public key of the subnet (a DER-encoded BLS key, see
    // https://sdk.dfinity.org/docs/interface-spec/index.html#certification)
    bytes public_key = 2;
    registry.subnet.v1.SubnetType subnet_type = 3;
    registry.subnet.v1.SubnetFeatures subnet_features = 4;
    repeated registry.crypto.v1.EcdsaKeyId ecdsa_keys_held = 5;
}

message SubnetsEntry {
    types.v1.SubnetId subnet_id = 1;
    SubnetTopology subnet_topology = 2;
}

message EcdsaKeyEntry {
    reserved 1;
    registry.crypto.v1.EcdsaKeyId key_id = 3;
    repeated types.v1.SubnetId subnet_ids = 2;
}

message NetworkTopology {
    repeated SubnetsEntry subnets = 1;
    registry.routing_table.v1.RoutingTable routing_table = 2;
    types.v1.SubnetId nns_subnet_id = 3;
    registry.routing_table.v1.CanisterMigrations canister_migrations = 4;
    repeated EcdsaKeyEntry ecdsa_signing_subnets = 5;
}

message SetupInitialDkgContext {
    state.queues.v1.Request request = 1;
    repeated types.v1.NodeId nodes_in_subnet = 2;
    reserved 3;
    reserved "subnet_id";
    bytes target_id = 4;
    uint64 registry_version = 5;
}

message SetupInitialDkgContextTree {
    uint64 callback_id = 1;
    SetupInitialDkgContext context = 2;
}

message SignWithEcdsaContext {
    state.queues.v1.Request request = 1;
    bytes pseudo_random_id = 2;
    bytes message_hash = 3;
    reserved 4;
    reserved "derivation_path";
    uint64 batch_time = 5;
    repeated bytes derivation_path_vec = 6;
    registry.crypto.v1.EcdsaKeyId key_id = 7;
}

message SignWithEcdsaContextTree {
    uint64 callback_id = 1;
    SignWithEcdsaContext context = 2;
}

enum HttpMethod {
    HTTP_METHOD_UNSPECIFIED = 0;
    HTTP_METHOD_GET = 1;
    HTTP_METHOD_POST = 2;
    HTTP_METHOD_HEAD = 3;
}

message HttpHeader {
    string name = 1;
    string value = 2;
}

message CanisterHttpRequestContext {
    state.queues.v1.Request request = 1;
    string url = 2;
    google.protobuf.BytesValue body = 3;
    google.protobuf.StringValue transform_method_name = 4;
    HttpMethod http_method = 8;
    uint64 time = 6;
    repeated HttpHeader headers = 7;
    optional uint64 max_response_bytes = 9;

    reserved 5;
}

message CanisterHttpRequestContextTree {
    uint64 callback_id = 1;
    CanisterHttpRequestContext context = 2;
}

message EcdsaDealingsContext {
    state.queues.v1.Request request = 1;
    reserved 2;
    repeated types.v1.NodeId nodes = 3;
    uint64 registry_version = 4;
    registry.crypto.v1.EcdsaKeyId key_id = 5;
}

message EcdsaDealingsContextTree {
    uint64 callback_id = 1;
    EcdsaDealingsContext context = 2;
}

message BitcoinGetSuccessorsContext {
    state.queues.v1.Request request = 1;
    bitcoin.v1.CanisterGetSuccessorsRequestInitial payload = 2;
}

message BitcoinGetSuccessorsContextTree {
    uint64 callback_id = 1;
    BitcoinGetSuccessorsContext context = 2;
}

message SubnetCallContextManager {
    uint64 next_callback_id = 1;
    reserved 2;
    reserved "contexts";
    repeated SetupInitialDkgContextTree setup_initial_dkg_contexts = 3;
    repeated SignWithEcdsaContextTree sign_with_ecdsa_contexts = 4;
    reserved 5;
    reserved "sign_with_mock_ecdsa_contexts";
    repeated CanisterHttpRequestContextTree canister_http_request_contexts = 6;
    repeated EcdsaDealingsContextTree ecdsa_dealings_contexts = 7;
    repeated BitcoinGetSuccessorsContextTree bitcoin_get_successors_contexts = 8;
}

message TimeOfLastAllocationCharge {
    uint64 time_of_last_allocation_charge_nanos = 1;
}

message SubnetMetrics {
    types.v1.NominalCycles consumed_cycles_by_deleted_canisters = 1;
}

message BitcoinGetSuccessorsFollowUpResponses {
  types.v1.CanisterId sender = 1;
  repeated bytes payloads = 2;
}

message SystemMetadata {
    uint64 generated_id_counter = 1;
    google.protobuf.BytesValue prev_state_hash = 2;
    uint64 batch_time_nanos = 3;
    ingress.v1.IngressHistoryState ingress_history = 4;
    repeated queues.v1.StreamEntry streams = 5;
    NetworkTopology network_topology = 6;
    types.v1.SubnetId own_subnet_id = 7;
    SubnetCallContextManager subnet_call_context_manager = 8;

    // Canister ID ranges allocated (exclusively) to this subnet, to generate
    // canister IDs from.
    registry.routing_table.v1.CanisterIdRanges canister_allocation_ranges = 16;
    // The last generated canister ID; or `None` if no canister ID has yet been
    // generated by this subnet.
    //
    // If present, must be within the first `CanisterIdRange` in
    // `canister_allocation_ranges` (and the latter may not be empty).
    types.v1.CanisterId last_generated_canister_id = 17;

    // Version of the StateSync protocol that should be used to compute
    // checkpoint manifests and transmit state.
    uint32 state_sync_version = 9;

    // Version of the certification protocol that should be used to
    // certify this state.
    uint32 certification_version = 10;

    uint64 heap_delta_estimate = 11;

    reserved 12;
    reserved "stable_memory_delta_estimate";

    registry.subnet.v1.SubnetFeatures own_subnet_features = 13;
    // TODO(EXC-1214): This field is deprecated.
    TimeOfLastAllocationCharge time_of_last_allocation_charge_nanos = 14;
    SubnetMetrics subnet_metrics = 15;

    repeated BitcoinGetSuccessorsFollowUpResponses bitcoin_get_successors_follow_up_responses = 18;
}

message StableMemory { bytes memory = 1; }
